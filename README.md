# NSASM MANUAL
NyaSama Assembly Script Module Manual
***
## Introduction (Java, C#)

### 注意: 操作符不区分大小写

#### 大概是8086的风格(其实这已经完全不是汇编了)

`目前实现了动态类型, 反射, 多态, 闭包等高等特性(大概是)`

***
### 代码示例

```
run <main>

<main> {
    mov r0, "test"
    code c = (
        prt r0
        prt r0, r0
        prt r0
    )
    eval r0, c
    out "r0 is "
    prt r0
    prt c, "prt \"hello, gensokyo\""
    eval r0, c
    out "r0 is"
    prt r0
    end
}
```

***
### 注释格式

```
rem "注释内容"
```
对这是一条指令, 还不能跨行(

***
### 变量声明

```
var 变量名 = 初始值
```
初始值可以为这些格式: `1, 0x1, 1h, 1.0, 1.0F, '1', "1", "1" * 重复次数`

其中重复次数除了可以是立即数, 还可以是其他整数型变量或寄存器

以下为详细说明

|数据类型|对应立即数|示例|
|-|-|-|
|整数|1, 0x1, 1h|var num = 0x32|
|浮点数|1.0, 1.0F|var f = 2.333|
|字符|'c', '\n'|var c = '\t'|
|字符串|"hello", "gensokyo" * 2|var str = "HO!" * num|

`需要注意的是, 字符串型变量声明后变量本身是只读的, 需要传送至一个通用寄存器`

`同时这个寄存器初始类型不能是字符型或字符串型`

#### 特殊变量声明

NSASM拥有类似于函数型变量的变量, 即把一段代码作为变量, 可以执行和追加

未来还会加入更多的特性(比如插入, 替换等)

多行代码声明如下, 此时等号右侧小括号范围内依然属于立即数
```
var c = (
    prt "hello, world!"
    prt "hello, gensokyo!"
)
```

单行代码声明如下
```
var c = ( prt "single" )
```

#### 显式常量声明

`因为特性设计(BUG), 这个大概算常量, 这样声明是不可写的`

要注意的是这样声明的话需要写出初始值

这样的好处是可以作为一般意义的常量在代码中使用
```
int a = 123
float b = 1.23
char c = 'c'
str s = "CHina"
str t = "t" * 10
code c = (
    int x = 3
    int y = 2
)
```

***
### 代码段声明

这里的代码段类似于8086汇编中的概念, 也类似于一般语言的函数的概念

同时, 函数型变量则类似于Java的Runnable接口以及C#的delegate

函数型变量的立即数则类似于Java和C#中的Lambda表达式

有基本格式(其中修饰符可省略)
```
修饰符<代码段名> {
    代码块
    ...
}
```

以下为示例
```
<func> {
    prt "hello"
    prt "this is a sample"
}

.<conf> {
    heap 64
    stack 32
    reg 16
}
```

特别地, 当代码段名左侧三角括号的左侧存在如下修饰符时

|修饰符|作用|
|-|-|
|. (小数点)|当段名为 `conf` 时, 为解释器配置段, 否则整个段不被解释器加载|
|@|当解释器中已经存在同名段时, 会覆盖掉已有的段, 否则解释器抛出错误|

#### 当修饰符为 `.` 小数点时
```
.<conf> {
    heap 64
    stack 32
    reg 16
}
```

`heap` 为堆大小配置(变量空间), `stack` 是栈大小配置, `reg` 是寄存器数目配置

这里仅可跟正的整数型立即数, 因为这部分代码不送入解释器执行

#### 当修饰符为 `@` 时

首先声明了如下段
```
<seg> {
    prt "hello"
}
```

然后声明如下段(或存在另外一个文件内加载)
```
@<seg> {
    prt "hello, gensokyo!"
}
```

此时执行 `seg` 段输出是 `hello, gensokyo!` 而非 `hello`

***
### 程序标号

这里的标号单独占一行, 使用 `[]` 包括, 而非传统汇编在指令头部
```
[head]
...
  jnz [head]
[tag]
  prt "..."
...
```

***
### 指令格式

```
指令名 目标操作数, 源操作数
指令名 操作数
指令名
```

需要注意的是, 在绝大部分双操作数指令中目标操作数不能是立即数

而在单操作数指令中, 其操作数要求视不同指令而不同

```
特别地, 函数型变量的立即数仅能作为双操作数指令的源操作数
而在绝大部分双操作数指令中, 函数型变量通常作为源操作数, 此时其代码会被执行
并返回一个值, 在未指定的情况下返回的是最后所使用的目标操作数
若指定则是返回所指定的操作数, 如立即数或寄存器
```

`需要注意的是, 在函数型变量中的代码里声明的变量不和函数型变量以外的冲突`

`同时将这些变量作为返回值是返回的拷贝, 原变量的对象在函数型变量执行完后就销毁了`

`因为函数型变量里的代码其实是在一个新的解释器实例下运行, 这个实例继承了来自父实例的寄存器组的拷贝`

`而子实例的堆栈大小和父实例相同, 但并未获取父实例的拷贝, 因此子实例的变量声明不和父实例冲突`

***
### 寄存器组

寄存器是ARM的风格, 并非是8086的AX, BX之类, 而是r0, r1

这寄存器更像是静态变量, 而非硬件意义上的寄存器

以下为介绍

|寄存器名|作用|
|-|-|
|r#|通用寄存器组, 其中#为编号, `r` 不区分大小写, 可直接在程序内使用|
|状态寄存器|用于程序流程控制, 不可在程序内直接使用, 需要由指令进行修改访问|
|段寄存器|用于程序流程控制, 不可在程序内直接使用, 需要由指令进行修改访问|
|程序计数器器|用于程序流程控制, 不可在程序内直接使用, 需要由指令进行修改访问|

***
### 指令一览

|指令名|作用|示例|备注|
|-|-|-|-|
|rem|行注释|rem "注释"|不作为实际代码运行|
|var|变量声明|var a = 0|不建议夹杂在普通指令内|
|int|整数型变量声明|int a = 0|不建议夹杂在普通指令内|
|char|字符型变量声明|char c = 'c'|不建议夹杂在普通指令内|
|float|浮点型变量声明|float f = 0.1|不建议夹杂在普通指令内|
|str|字符串型变量声明|str s = "string"|不建议夹杂在普通指令内|
|code|函数型变量声明|code c = ( ret 0 )|不建议夹杂在普通指令内|
|mov|数据传送指令|mov r0, r1|存在重载指令|
|push|压栈指令|push r0|-|
|pop|出栈指令|pop r1|-|
|in|IO输入指令|in 0x00, r0|存在重载指令|
|out|IO输出指令|out "12345"|存在重载指令|
|prt|屏幕打印指令|prt "hello"|存在重载指令|
|add|算数加法指令|add r0, 2|源操作数为函数型变量时会执行代码|
|inc|算数加一指令|inc r0|-|
|sub|算数减法指令|sub r2, 1.3|源操作数为函数型变量时会执行代码|
|dec|算数减一指令|dec r1|-|
|mul|算数乘法指令|mul r1, 2|源操作数为函数型变量时会执行代码|
|div|算数除法指令|div r2, 1.5F|源操作数为函数型变量时会执行代码|
|and|逻辑与指令|and r0, 0x7F|源操作数为函数型变量时会执行代码|
|or|逻辑或指令|or r0, 0x40|源操作数为函数型变量时会执行代码|
|xor|逻辑异或指令|xor r0, r0|源操作数为函数型变量时会执行代码|
|not|逻辑非指令|not r12|-|
|shl|逻辑左移指令|shl r0, 4|源操作数为函数型变量时会执行代码|
|shr|逻辑右移指令|shr r0, 2|源操作数为函数型变量时会执行代码|
|cmp|比较指令|cmp r0, 0|源操作数为函数型变量时会执行代码, 会修改状态寄存器|
|test|测试指令|test r1|会修改状态寄存器|
|jmp|无条件转移指令|jmp [tag]|-|
|jz|条件转移指令|jz [tag]|状态寄存器为零时跳转|
|jnz|条件转移指令|jnz [head]|状态寄存器非零时跳转|
|jg|条件转移指令|jg [tag]|状态寄存器大于零时跳转|
|jl|条件转移指令|jl [head]|状态寄存器小于零时跳转|
|end|程序结束指令|end|不存在操作的寄存器|
|ret|结果返回指令|ret 0|存在重载指令|
|nop|空操作指令|nop|-|
|rst|复位指令|rst|会修改段寄存器和程序计数器|
|run|段执行(跳转)指令|run \<seg\>|会修改段寄存器和程序计数器|
|call|段调用指令|call \<seg\>|会修改段寄存器和程序计数器|
|ld|程序加载指令|ld "test.ns"|会修改程序缓存区|
|eval|函数型变量执行指令|eval r0, c|存在重载指令|

这里的指令仅包含原生的NSASM指令集, 不含重载指令集

#### 部分指令解释

```
TODO
```

***
### 运行原理

解释器加载程序后, 会将段外的代码集中到一起, 作为公共段加载, 并优先运行

公共段程序运行完成后且未终止解释器, 解释器会按文件顺序运行各个段的程序

程序是按文件内的顺序逐行执行, 报错会给出段名和行号

运行过程中若用程序加载指令加载新的程序, 并且新程序中有同名的带有覆盖修饰符的段时

原段会被新段覆盖, 加载指令之后对这个段的调用是调用的新段的程序

***
### 高阶用法

这里有部分代码参考

<url>https://github.com/NSDN/NyaSamaRailway/blob/master/src/main/java/club/nsdn/nyasamarailway/Util/NSASM.java</url>

***
### 其他

目前不建议在函数型变量内进行段声明, 这里会有bug, 等待后续修复

***
#### Copyright © NSDN 2014 - 2018
